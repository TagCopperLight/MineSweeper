\begin{MintedVerbatim}[commandchars=\\\{\}]
        Fonction lode\PYGZus{}runner en action
        Parametres :
            level en levelinfo
            characterl en character\PYGZus{}list
            bonusl en bonus\PYGZus{}list
            bombl en bomb\PYGZus{}list
        Declarations :
            runner en character\PYGZus{}list
            astar\PYGZus{}level en levelinfo
            already\PYGZus{}seen en bonus\PYGZus{}list
            closest\PYGZus{}bonus en bonus\PYGZus{}list
            to\PYGZus{}exit en booléen
            move\PYGZus{}to\PYGZus{}combat en entier
            move\PYGZus{}to\PYGZus{}closest en entier
            move\PYGZus{}to\PYGZus{}path en entier
            move\PYGZus{}to\PYGZus{}skipped en entier
            @pat en path
            @c en child
            tmp en bonus\PYGZus{}list
            v en entier
        Debut
            runner \PYGZlt{}\PYGZhy{} get\PYGZus{}runner(characterl) // On récupère le runner
            level \PYGZlt{}\PYGZhy{} add\PYGZus{}enemies(level, characterl, bombl) // On ajoute les ennemis à la carte
            // On créé un niveau pour A* avec des zones autour des ennemis. Le but est que le runner ne s\PYGZsq{}approche pas trop des ennemis
            astar\PYGZus{}level \PYGZlt{}\PYGZhy{} get\PYGZus{}astar\PYGZus{}level(level, characterl)

            already\PYGZus{}seen \PYGZlt{}\PYGZhy{} NULL // On initialise la liste des bonus déjà vus
            closest\PYGZus{}bonus \PYGZlt{}\PYGZhy{} get\PYGZus{}closest\PYGZus{}bonus(bonusl, runner, already\PYGZus{}seen) // On récupère le bonus le plus proche

            Si bonusl == NULL alors
                // Si la liste des bonus est vide, c\PYGZsq{}est qu\PYGZsq{}on les a tous récupérés, on va donc vers la sortie
                // On crée un bonus fictif qui possède les coordonnées de la sortie
                closest\PYGZus{}bonus \PYGZlt{}\PYGZhy{} malloc(sizeof(bonus\PYGZus{}list))
                bonus b \PYGZlt{}\PYGZhy{} \PYGZob{}level.xexit, level.yexit\PYGZcb{}
                closest\PYGZus{}bonus\PYGZhy{}\PYGZgt{}b \PYGZlt{}\PYGZhy{} b
                to\PYGZus{}exit \PYGZlt{}\PYGZhy{} VRAI
            Fin Si

            // Ces variables vont stocker les actions à effectuer, elles sont initialisées à \PYGZhy{}1 pour qu\PYGZsq{}on sache si elles ont été modifiées
            move\PYGZus{}to\PYGZus{}combat \PYGZlt{}\PYGZhy{} \PYGZhy{}1
            move\PYGZus{}to\PYGZus{}closest \PYGZlt{}\PYGZhy{} \PYGZhy{}1
            move\PYGZus{}to\PYGZus{}path \PYGZlt{}\PYGZhy{} \PYGZhy{}1
            move\PYGZus{}to\PYGZus{}skipped \PYGZlt{}\PYGZhy{} \PYGZhy{}1

            Tant que closest\PYGZus{}bonus != NULL faire
                // On itère sur les bonus
                pat \PYGZlt{}\PYGZhy{} a\PYGZus{}star(runner, closest\PYGZus{}bonus, astar\PYGZus{}level, level) // On calcule le chemin vers le bonus le plus proche
                Si level.map[closest\PYGZus{}bonus\PYGZhy{}\PYGZgt{}b.y][closest\PYGZus{}bonus\PYGZhy{}\PYGZgt{}b.x] == ENEMY alors
                    // Cas spécial : si un ennemi est sur le bonus, on ne peut pas y aller (A* ne trouvera pas de chemin)
                    int runner\PYGZus{}pos \PYGZlt{}\PYGZhy{} runner\PYGZhy{}\PYGZgt{}c.y * level.xsize + runner\PYGZhy{}\PYGZgt{}c.x
                    int closest\PYGZus{}bonus\PYGZus{}pos \PYGZlt{}\PYGZhy{} closest\PYGZus{}bonus\PYGZhy{}\PYGZgt{}b.y * level.xsize + closest\PYGZus{}bonus\PYGZhy{}\PYGZgt{}b.x
                    c \PYGZlt{}\PYGZhy{} find\PYGZus{}closest\PYGZus{}child(pat\PYGZhy{}\PYGZgt{}p, runner\PYGZus{}pos, closest\PYGZus{}bonus\PYGZus{}pos, level) // On trouve le chemin qui nous rapproche le plus du bonus
                    move\PYGZus{}to\PYGZus{}skipped \PYGZlt{}\PYGZhy{} get\PYGZus{}action(runner\PYGZus{}pos, c\PYGZhy{}\PYGZgt{}pos, level) // On stocke l\PYGZsq{}action à effectuer
                    // On ajoute le bonus à la liste des bonus déjà vus
                    tmp \PYGZlt{}\PYGZhy{} malloc(sizeof(bonus\PYGZus{}list))
                    tmp\PYGZhy{}\PYGZgt{}b \PYGZlt{}\PYGZhy{} closest\PYGZus{}bonus\PYGZhy{}\PYGZgt{}b
                    tmp\PYGZhy{}\PYGZgt{}next \PYGZlt{}\PYGZhy{} already\PYGZus{}seen
                    already\PYGZus{}seen \PYGZlt{}\PYGZhy{} tmp
                    Si non to\PYGZus{}exit alors
                        // Si il y a d\PYGZsq{}autres bonus, on récupère le plus proche pour continuer la boucle
                        closest\PYGZus{}bonus \PYGZlt{}\PYGZhy{} get\PYGZus{}closest\PYGZus{}bonus(bonusl, runner, already\PYGZus{}seen)
                    Fin Si
                    Continuer
                Fin Si

                Si move\PYGZus{}to\PYGZus{}closest == \PYGZhy{}1 alors
                    // Si on n\PYGZsq{}a toujours initialisé move\PYGZus{}to\PYGZus{}closest, on le fait
                    // move\PYGZus{}to\PYGZus{}closest est l\PYGZsq{}action qui nous rapproche du bonus le plus proche (même s\PYGZsq{}il est inaccessible)
                    int runner\PYGZus{}pos \PYGZlt{}\PYGZhy{} runner\PYGZhy{}\PYGZgt{}c.y * level.xsize + runner\PYGZhy{}\PYGZgt{}c.x
                    int closest\PYGZus{}bonus\PYGZus{}pos \PYGZlt{}\PYGZhy{} closest\PYGZus{}bonus\PYGZhy{}\PYGZgt{}b.y * level.xsize + closest\PYGZus{}bonus\PYGZhy{}\PYGZgt{}b

                    c \PYGZlt{}\PYGZhy{} find\PYGZus{}closest\PYGZus{}child(pat\PYGZhy{}\PYGZgt{}p, runner\PYGZus{}pos, closest\PYGZus{}bonus\PYGZus{}pos, level) // On trouve le chemin qui nous rapproche le plus du bonus
                    move\PYGZus{}to\PYGZus{}closest \PYGZlt{}\PYGZhy{} get\PYGZus{}action(runner\PYGZus{}pos, c\PYGZhy{}\PYGZgt{}pos, level) // On stocke l\PYGZsq{}action à effectuer
                Fin Si

                Si pat\PYGZhy{}\PYGZgt{}found alors
                    // Si on a trouvé un chemin, on le suit
                    v \PYGZlt{}\PYGZhy{} closest\PYGZus{}bonus\PYGZhy{}\PYGZgt{}b.y * level.xsize + closest\PYGZus{}bonus\PYGZhy{}\PYGZgt{}b.x
                    Tant que pat\PYGZhy{}\PYGZgt{}p[v] != runner\PYGZhy{}\PYGZgt{}c.y * level.xsize + runner\PYGZhy{}\PYGZgt{}c.x faire
                        // pat\PYGZhy{}\PYGZgt{}p[v] est le parent de v, on remonte le chemin pour trouver l\PYGZsq{}action à effectuer
                        v \PYGZlt{}\PYGZhy{} pat\PYGZhy{}\PYGZgt{}p[v]
                    Fin Tant que

                    move\PYGZus{}to\PYGZus{}path \PYGZlt{}\PYGZhy{} get\PYGZus{}action(runner\PYGZhy{}\PYGZgt{}c.y * level.xsize + runner\PYGZhy{}\PYGZgt{}c.x, v, level) // On stocke l\PYGZsq{}action à effectuer

                Sinon Si pat\PYGZhy{}\PYGZgt{}heap\PYGZhy{}\PYGZgt{}size != 0 alors
                    // Si le chemin est plus long que la taille du tas, c\PYGZsq{}est une erreur
                    Afficher \PYGZdq{}ERROR: Path is longer than heap size\PYGZdq{}
                    Sortir du programme
                Sinon
                    // Si on n\PYGZsq{}a pas trouvé de chemin, on est en mode combat
                    combat\PYGZus{}moves(runner, get\PYGZus{}closest\PYGZus{}enemy(characterl, runner, level), \PYGZam{}move\PYGZus{}to\PYGZus{}combat, level)
                Fin Si

                // On ajoute le bonus à la liste des bonus déjà vus
                tmp \PYGZlt{}\PYGZhy{} malloc(sizeof(bonus\PYGZus{}list))
                tmp\PYGZhy{}\PYGZgt{}b \PYGZlt{}\PYGZhy{} closest\PYGZus{}bonus\PYGZhy{}\PYGZgt{}b
                tmp\PYGZhy{}\PYGZgt{}next \PYGZlt{}\PYGZhy{} already\PYGZus{}seen
                already\PYGZus{}seen \PYGZlt{}\PYGZhy{} tmp
                Si non to\PYGZus{}exit alors
                    // Si il y a d\PYGZsq{}autres bonus, on récupère le plus proche pour continuer la boucle
                    closest\PYGZus{}bonus \PYGZlt{}\PYGZhy{} get\PYGZus{}closest\PYGZus{}bonus(bonusl, runner, already\PYGZus{}seen)
                Sinon
                    closest\PYGZus{}bonus \PYGZlt{}\PYGZhy{} NULL
                Fin Si
            Fin Tant que

            Si move\PYGZus{}to\PYGZus{}path != \PYGZhy{}1 alors
                // On a trouvé un chemin, on le suit
                Retourner move\PYGZus{}to\PYGZus{}path
            Sinon Si move\PYGZus{}to\PYGZus{}combat != \PYGZhy{}1 alors
                // On est en mode combat
                Retourner move\PYGZus{}to\PYGZus{}combat
            Sinon Si move\PYGZus{}to\PYGZus{}closest != \PYGZhy{}1 alors
                // On n\PYGZsq{}a pas trouvé de chemin, on se rapproche du bonus
                Si is\PYGZus{}valid\PYGZus{}closest(runner\PYGZhy{}\PYGZgt{}c.y * level.xsize + runner\PYGZhy{}\PYGZgt{}c.x, move\PYGZus{}to\PYGZus{}closest, astar\PYGZus{}level) alors
                    Retourner move\PYGZus{}to\PYGZus{}closest
                Sinon
                    Retourner NONE
                Fin Si
            Sinon
                // Les bonus sont inaccessibles, on cherche le chemin qui nous rapproche le plus d\PYGZsq{}un bonus
                Retourner move\PYGZus{}to\PYGZus{}skipped
            Fin Si
        Fin
\end{MintedVerbatim}
